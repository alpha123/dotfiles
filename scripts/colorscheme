#!/usr/bin/env ruby

require 'yaml'

# colorscheme_dir is the directory where all the YAML color scheme files are stored,
# current_colorscheme is the path to a symlink to a file in that directory.
$colorscheme_dir = "#{ENV['HOME']}/colorschemes"
$current_colorscheme = "#{ENV['HOME']}/.colorscheme"
$i3_config = "#{ENV['HOME']}/.i3/config"
$i3_config_marker_start = "### Autogenerated by ~/scripts/colorscheme ###"
$i3_config_marker_end = "### End autogenerated section ###"
$lxpanel_config = "#{ENV['HOME']}/.config/lxpanel/default/panels/panel"
#$lxpanel_config_marker_start = ["### tintcolor autogenerated by ~/scripts/colorscheme ###",
                                #"### fontcolor autogenerated by ~/scripts/colorscheme ###"]
#$lxpanel_config_marker_end = ["### End autogenerated tintcolor ###",
                              #"### End autogenerated fontcolor ###"]
$lxpanel_config_marker_start = ["    tintcolor=", "    fontcolor="]
$lxpanel_config_marker_end = ["\n    alpha", "\n    usefontsize"]
$xresources = "#{ENV['HOME']}/.Xresources"

def get_colorschemes(dir, current)
    # Exclude . and .. which Dir.entries returns
    colorschemes = Dir.entries(dir)[2..-1]
    colorschemes.map do |name|
        if File.readlink(current) == "#{dir}/#{name}"
            name + '*'
        else
            name
        end
    end
end

def switch_colorscheme(dir, current, newname)
    newpath = "#{dir}/#{newname}"
    File.unlink current
    File.symlink newpath, current
    colors = YAML.load_file newpath
    write_i3_config colors
    write_lxpanel_config colors
    write_xresources colors
    switch_background colors
end

def reload_everything
    `xrdb -merge ~/.Xresources`
    # Tell i3 to reload its config and restart lxpanel to force it to reload.
    `i3-msg reload`
    # For some reason using backticks instead of system causes the & not to return immediately.
    system("killall lxpanel; lxpanel &")
end

def change_config(config_file, start_marker, end_marker, &get_new_config)
    # Read the whole file in, replace the part between the markers,
    # and then write it back out.
    config_text = IO.read config_file
    new_section = get_new_config.call
    new_config = config_text.gsub(/#{Regexp.escape start_marker}(.*)?#{Regexp.escape end_marker}/m,
                                start_marker + new_section + end_marker)
    IO.write config_file, new_config
end

def write_i3_config(colors)
    return unless colors['i3']
    change_config($i3_config, $i3_config_marker_start, $i3_config_marker_end) do
        new_i3_config colors
    end
end

def new_i3_config(colorscheme)
    colors = colorscheme['i3']
    <<-CONFIG

client.focused          #{i3_color_line colors['focused']}
client.focused_inactive #{i3_color_line colors['focused_inactive']}
client.unfocused        #{i3_color_line colors['unfocused']}
client.urgent           #{i3_color_line colors['urgent']}
    CONFIG
end

def i3_color_line(colors)
    colors['border'] + ' ' + colors['bg'] + ' ' + colors['text'] + ' ' + colors['indicator']
end

def write_lxpanel_config(colors)
    return unless colors['lxpanel']
    change_config($lxpanel_config, $lxpanel_config_marker_start[0], $lxpanel_config_marker_end[0]) do
        colors['lxpanel']['bg']
        #"    tintcolor=#{colors['lxpanel']['bg']}\n    "
    end
    change_config($lxpanel_config, $lxpanel_config_marker_start[1], $lxpanel_config_marker_end[1]) do
        colors['lxpanel']['fg']
        #"    fontcolor=#{colors['lxpanel']['fg']}\n    "
    end
end

def write_xresources(colors)
    return unless colors['xresources']
    text = nil
    open $xresources do |xfile|
        text = xfile.read
        colors['xresources'].each do |key, resource|
            write_resource resource, key, text
        end
    end
    open($xresources, 'w') { |xfile| xfile.write text }
end

def write_resource(resource, key, text)
    if resource.is_a? Hash
        resource.each do |k, r|
            write_resource r, "#{key}.#{k}", text
        end
    else
        text.gsub!(/^#{key}:.*$/, "#{key}: #{resource}")
    end
end

def switch_background(colors)
    return unless colors['background']
    `feh --bg-fill #{colors['background']}`
end

if ARGV.length > 0
    switch_colorscheme $colorscheme_dir, $current_colorscheme, ARGV[0]
    reload_everything
    puts "Colorscheme is now #{ARGV[0]}."
else
    puts 'Usage: colorscheme [schemename]'
    puts 'Available colorschemes (* = active):'
    get_colorschemes($colorscheme_dir, $current_colorscheme).each {|s| puts s}
end
